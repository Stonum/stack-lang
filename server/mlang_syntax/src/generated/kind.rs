//! Generated file, do not edit by hand, see `xtask/codegen`

#![allow(clippy::all)]
#![allow(bad_style, missing_docs, unreachable_pub)]
#[doc = r" The kind of syntax node, e.g. `IDENT`, `FUNCTION_KW`, or `FOR_STMT`."]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
#[repr(u16)]
pub enum MSyntaxKind {
    #[doc(hidden)]
    TOMBSTONE,
    #[doc = r" Marks the end of the file. May have trivia attached"]
    EOF,
    #[doc = r" Any Unicode BOM character that may be present at the start of"]
    #[doc = r" a file."]
    UNICODE_BOM,
    SEMICOLON,
    COMMA,
    L_PAREN,
    R_PAREN,
    L_CURLY,
    R_CURLY,
    L_BRACK,
    R_BRACK,
    L_ANGLE,
    R_ANGLE,
    QUESTION,
    AMP,
    PIPE,
    PLUS,
    PLUS2,
    STAR,
    SLASH,
    CARET,
    PERCENT,
    DOT,
    DOT3,
    COLON,
    EQ,
    EQ2,
    BANG,
    NEQ,
    MINUS,
    MINUS2,
    LTEQ,
    GTEQ,
    PLUSEQ,
    MINUSEQ,
    SLASHEQ,
    STAREQ,
    PERCENTEQ,
    AMP2,
    PIPE2,
    AT,
    BACKTICK,
    FF,
    FF2,
    BREAK_KW,
    CASE_KW,
    CATCH_KW,
    CLASS_KW,
    CLASSOF_KW,
    CONTINUE_KW,
    DEBUG_KW,
    DELETE_KW,
    DO_KW,
    ELSE_KW,
    EXTENDS_KW,
    FALSE_KW,
    FINALLY_KW,
    FOR_KW,
    FORALL_KW,
    FUNCTION_KW,
    IF_KW,
    IN_KW,
    IN2_KW,
    INCLUDE_IN_KW,
    INSTANCEOF_KW,
    NEW_KW,
    NULL_KW,
    RETURN_KW,
    SUPER_KW,
    SWITCH_KW,
    THIS_KW,
    THROW_KW,
    TRY_KW,
    TRUE_KW,
    VAR_KW,
    WHILE_KW,
    K_KW,
    VERSION_KW,
    STATIC_KW,
    AND_KW,
    OR_KW,
    INLINE_KW,
    CONSTRUCTOR_KW,
    GET_KW,
    SET_KW,
    M_NUMBER_LITERAL,
    M_STRING_LITERAL,
    M_LONG_STRING_LITERAL,
    M_DATE_LITERAL,
    M_TIME_LITERAL,
    ERROR_TOKEN,
    IDENT,
    NEWLINE,
    WHITESPACE,
    COMMENT,
    M_MODULE,
    M_MODULE_ITEM_LIST,
    M_SCRIPT,
    M_REPORT_FILE,
    M_EXPRESSION_SNIPPED,
    M_DIRECTIVE,
    M_DIRECTIVE_LIST,
    M_STATEMENT_LIST,
    M_BLOCK_STATEMENT,
    M_FUNCTION_BODY,
    M_VARIABLE_STATEMENT,
    M_VARIABLE_DECLARATION,
    M_VARIABLE_DECLARATOR_LIST,
    M_VARIABLE_DECLARATOR,
    M_VARIABLE_DECLARATION_CLAUSE,
    M_INITIALIZER_CLAUSE,
    M_EMPTY_STATEMENT,
    M_EXPRESSION_STATEMENT,
    M_IF_STATEMENT,
    M_ELSE_CLAUSE,
    M_WHILE_STATEMENT,
    M_FOR_STATEMENT,
    M_FOR_ALL_IN_STATEMENT,
    M_FOR_ALL_STATEMENT,
    M_FOR_VARIABLE_DECLARATION,
    M_FOR_ITERATOR_FACTORY,
    M_CONTINUE_STATEMENT,
    M_BREAK_STATEMENT,
    M_RETURN_STATEMENT,
    M_SWITCH_STATEMENT,
    M_SWITCH_CASE_LIST,
    M_CASE_CLAUSE,
    M_DEFAULT_CLAUSE,
    M_THROW_STATEMENT,
    M_TRY_STATEMENT,
    M_TRY_FINALLY_STATEMENT,
    M_CATCH_CLAUSE,
    M_CATCH_DECLARATION,
    M_FINALLY_CLAUSE,
    M_DEBUG_STATEMENT,
    M_FUNCTION_DECLARATION,
    M_PARAMETERS,
    M_PARAMETER_LIST,
    M_FORMAL_PARAMETER,
    M_REST_PARAMETER,
    M_BINDING_PATTERN,
    M_IDENTIFIER_BINDING,
    M_EXTENDED_BINDING,
    M_IDENTIFIER_EXPRESSION,
    M_INSTANCEOF_EXPRESSION,
    M_REFERENCE_IDENTIFIER,
    M_NAME,
    M_PRIVATE_NAME,
    M_THIS_EXPRESSION,
    M_ARRAY_EXPRESSION,
    M_ARRAY_ELEMENT_LIST,
    M_ARRAY_HOLE,
    M_COMPUTED_MEMBER_NAME,
    M_LITERAL_MEMBER_NAME,
    M_HASH_MAP_EXPRESSION,
    M_HASH_MAP_MEMBER_LIST,
    M_HASH_SET_EXPRESSION,
    M_HASH_SET_ELEMENT_LIST,
    M_OBJECT_EXPRESSION,
    M_OBJECT_MEMBER_LIST,
    M_PROPERTY_OBJECT_MEMBER,
    M_SUPER_EXPRESSION,
    M_PARENTHESIZED_EXPRESSION,
    M_NEW_EXPRESSION,
    M_FUNCTION_EXPRESSION,
    M_STATIC_MEMBER_EXPRESSION,
    M_COMPUTED_MEMBER_EXPRESSION,
    M_CONSTANT_EXPRESSION,
    M_CALL_EXPRESSION,
    M_UNARY_EXPRESSION,
    M_PRE_UPDATE_EXPRESSION,
    M_POST_UPDATE_EXPRESSION,
    M_BINARY_EXPRESSION,
    M_IN_EXPRESSION,
    M_IN_PROPERTY,
    M_LOGICAL_EXPRESSION,
    M_CONDITIONAL_EXPRESSION,
    M_ASSIGNMENT_EXPRESSION,
    M_SEQUENCE_EXPRESSION,
    M_CALL_ARGUMENTS,
    M_CALL_ARGUMENT_LIST,
    M_STRING_LITERAL_EXPRESSION,
    M_NUMBER_LITERAL_EXPRESSION,
    M_BOOLEAN_LITERAL_EXPRESSION,
    M_NULL_LITERAL_EXPRESSION,
    M_LONG_STRING_LITERAL_EXPRESSION,
    M_DATE_LITERAL_EXPRESSION,
    M_TIME_LITERAL_EXPRESSION,
    M_SHORTHAND_PROPERTY_OBJECT_MEMBER,
    M_SPREAD,
    M_CLASS_DECLARATION,
    M_CLASS_EXPRESSION,
    M_CLASS_MEMBER_LIST,
    M_CLASS_MEMBER_NAME,
    M_EXTENDS_CLAUSE,
    M_CONSTRUCTOR_CLASS_MEMBER,
    M_CONSTRUCTOR_MODIFIER_LIST,
    M_CONSTRUCTOR_PARAMETER_LIST,
    M_CONSTRUCTOR_PARAMETERS,
    M_PROPERTY_CLASS_MEMBER,
    M_PROPERTY_MODIFIER_LIST,
    M_METHOD_CLASS_MEMBER,
    M_METHOD_MODIFIER_LIST,
    M_GETTER_CLASS_MEMBER,
    M_SETTER_CLASS_MEMBER,
    M_PARENTHESIZED_ASSIGNMENT,
    M_IDENTIFIER_ASSIGNMENT,
    M_STATIC_MEMBER_ASSIGNMENT,
    M_COMPUTED_MEMBER_ASSIGNMENT,
    M_BOGUS,
    M_BOGUS_EXPRESSION,
    M_BOGUS_STATEMENT,
    M_BOGUS_MEMBER,
    M_BOGUS_BINDING,
    M_BOGUS_PARAMETER,
    M_BOGUS_ASSIGNMENT,
    M_ANNOTATION_GROUP_LIST,
    M_ANNOTATION_GROUP,
    M_ANNOTATION_LIST,
    M_ANNOTATION_BINDING,
    M_ANNOTATION_ELEMENT,
    M_ANNOTATION_ATTRIBUTE_LIST,
    M_ANNOTATION_ATTRIBUTE,
    M_REPORT,
    M_REPORT_LIST,
    M_REPORT_NAME,
    M_REPORT_INIT_LIST,
    M_REPORT_SECTION,
    M_REPORT_SECTION_LIST,
    M_REPORT_SECTION_NAME,
    #[doc(hidden)]
    __LAST,
}
use self::MSyntaxKind::*;
impl MSyntaxKind {
    pub const fn is_punct(self) -> bool {
        match self {
            SEMICOLON | COMMA | L_PAREN | R_PAREN | L_CURLY | R_CURLY | L_BRACK | R_BRACK
            | L_ANGLE | R_ANGLE | QUESTION | AMP | PIPE | PLUS | PLUS2 | STAR | SLASH | CARET
            | PERCENT | DOT | DOT3 | COLON | EQ | EQ2 | BANG | NEQ | MINUS | MINUS2 | LTEQ
            | GTEQ | PLUSEQ | MINUSEQ | SLASHEQ | STAREQ | PERCENTEQ | AMP2 | PIPE2 | AT
            | BACKTICK | FF | FF2 => true,
            _ => false,
        }
    }
    pub const fn is_literal(self) -> bool {
        match self {
            M_NUMBER_LITERAL
            | M_STRING_LITERAL
            | M_LONG_STRING_LITERAL
            | M_DATE_LITERAL
            | M_TIME_LITERAL => true,
            _ => false,
        }
    }
    pub const fn is_list(self) -> bool {
        match self {
            M_MODULE_ITEM_LIST
            | M_DIRECTIVE_LIST
            | M_STATEMENT_LIST
            | M_VARIABLE_DECLARATOR_LIST
            | M_SWITCH_CASE_LIST
            | M_PARAMETER_LIST
            | M_ARRAY_ELEMENT_LIST
            | M_OBJECT_MEMBER_LIST
            | M_HASH_MAP_MEMBER_LIST
            | M_HASH_SET_ELEMENT_LIST
            | M_CALL_ARGUMENT_LIST
            | M_CLASS_MEMBER_LIST
            | M_CONSTRUCTOR_MODIFIER_LIST
            | M_CONSTRUCTOR_PARAMETER_LIST
            | M_PROPERTY_MODIFIER_LIST
            | M_METHOD_MODIFIER_LIST
            | M_ANNOTATION_GROUP_LIST
            | M_ANNOTATION_LIST
            | M_ANNOTATION_ATTRIBUTE_LIST
            | M_REPORT_LIST
            | M_REPORT_INIT_LIST
            | M_REPORT_SECTION_LIST => true,
            _ => false,
        }
    }
    pub fn from_keyword(ident: &str) -> Option<MSyntaxKind> {
        let kw = match ident {
            "and" | "и" => AND_KW,
            "break" | "прервать" => BREAK_KW,
            "case" | "выбор" => CASE_KW,
            "catch" | "исключение" | "перехват" => CATCH_KW,
            "class" | "класс" => CLASS_KW,
            "classof" | "получитьКласс" => CLASSOF_KW,
            "constructor" | "" => CONSTRUCTOR_KW,
            "continue" | "продолжить" => CONTINUE_KW,
            "debug" | "отладить" => DEBUG_KW,
            "delete" | "удалить" => DELETE_KW,
            "else" | "иначе" => ELSE_KW,
            "extends" | "расширяет" => EXTENDS_KW,
            "false" | "ложь" => FALSE_KW,
            "finally" | "заключение" => FINALLY_KW,
            "for" | "для" => FOR_KW,
            "forall" | "длявсех" => FORALL_KW,
            "func" | "функция" => FUNCTION_KW,
            "get" | "получить" => GET_KW,
            "if" | "если" => IF_KW,
            "in" => IN_KW,
            "instanceof" | "экземпляр" => INSTANCEOF_KW,
            "в" => IN2_KW,
            "входитв" => INCLUDE_IN_KW,
            "new" | "новый" => NEW_KW,
            "null" | "nil" | "нуль" => NULL_KW,
            "return" | "вернуть" => RETURN_KW,
            "super" | "базовый" => SUPER_KW,
            "switch" | "выборпо" => SWITCH_KW,
            "set" | "установить" => SET_KW,
            "or" | "или" => OR_KW,
            "inline" => INLINE_KW,
            "this" | "этот" => THIS_KW,
            "throw" | "вызватьисключение" => THROW_KW,
            "try" | "попытка" => TRY_KW,
            "true" | "истина" => TRUE_KW,
            "while" | "пока" => WHILE_KW,
            "var" | "перем" => VAR_KW,
            "k" | "к" => K_KW,
            "version" => VERSION_KW,
            "static" | "статический" => STATIC_KW,
            _ => return None,
        };
        Some(kw)
    }
    pub const fn to_string(&self) -> Option<&'static str> {
        let tok = match self {
            SEMICOLON => ";",
            COMMA => ",",
            L_PAREN => "(",
            R_PAREN => ")",
            L_CURLY => "{",
            R_CURLY => "}",
            L_BRACK => "[",
            R_BRACK => "]",
            L_ANGLE => "<",
            R_ANGLE => ">",
            QUESTION => "?",
            AMP => "&",
            PIPE => "|",
            PLUS => "+",
            PLUS2 => "++",
            STAR => "*",
            SLASH => "/",
            CARET => "^",
            PERCENT => "%",
            DOT => ".",
            DOT3 => "...",
            COLON => ":",
            EQ => "=",
            EQ2 => "==",
            BANG => "!",
            NEQ => "!=",
            MINUS => "-",
            MINUS2 => "--",
            LTEQ => "<=",
            GTEQ => ">=",
            PLUSEQ => "+=",
            MINUSEQ => "-=",
            SLASHEQ => "/=",
            STAREQ => "*=",
            PERCENTEQ => "%=",
            AMP2 => "&&",
            PIPE2 => "||",
            AT => "@",
            BACKTICK => "`",
            FF => "",
            FF2 => "",
            M_STRING_LITERAL => "string literal",
            M_LONG_STRING_LITERAL => "long string literal",
            M_NUMBER_LITERAL => "number literal",
            K_KW | IN2_KW | INCLUDE_IN_KW => return self.to_ru_keyword(),
            _ => return self.to_en_keyword(),
        };
        Some(tok)
    }

    pub const fn to_en_keyword(&self) -> Option<&'static str> {
        let tok = match self {
            BREAK_KW => "break",
            CASE_KW => "case",
            CATCH_KW => "catch",
            CLASS_KW => "class",
            CLASSOF_KW => "classof",
            CONTINUE_KW => "continue",
            DEBUG_KW => "debug",
            DELETE_KW => "delete",
            DO_KW => "do",
            ELSE_KW => "else",
            EXTENDS_KW => "extends",
            FALSE_KW => "false",
            FINALLY_KW => "finally",
            FOR_KW => "for",
            FORALL_KW => "forall",
            FUNCTION_KW => "func",
            IF_KW => "if",
            IN_KW => "in",
            INSTANCEOF_KW => "instanceof",
            NEW_KW => "new",
            NULL_KW => "null",
            RETURN_KW => "return",
            STATIC_KW => "static",
            SUPER_KW => "super",
            SWITCH_KW => "switch",
            THIS_KW => "this",
            THROW_KW => "throw",
            TRY_KW => "try",
            TRUE_KW => "true",
            VAR_KW => "var",
            WHILE_KW => "while",
            AND_KW => "and",
            OR_KW => "or",
            INLINE_KW => "inline",
            CONSTRUCTOR_KW => "constructor",
            GET_KW => "get",
            SET_KW => "set",
            VERSION_KW => "version",
            K_KW => "k",
            _ => return None,
        };
        Some(tok)
    }

    pub const fn to_ru_keyword(&self) -> Option<&'static str> {
        let tok = match self {
            BREAK_KW => "прервать",
            CASE_KW => "Выбор",
            CATCH_KW => "Исключение",
            CLASS_KW => "Класс",
            CLASSOF_KW => "получитьКласс",
            CONTINUE_KW => "продолжить",
            DEBUG_KW => "отладить",
            DELETE_KW => "удалить",
            ELSE_KW => "Иначе",
            EXTENDS_KW => "расширяет",
            FALSE_KW => "ложь",
            FINALLY_KW => "Заключение",
            FOR_KW => "Для",
            FORALL_KW => "ДляВсех",
            FUNCTION_KW => "Функция",
            IF_KW => "Если",
            IN_KW => "в",
            IN2_KW => "в",
            INCLUDE_IN_KW => "входитв",
            INSTANCEOF_KW => "экземпляр",
            NEW_KW => "новый",
            NULL_KW => "нуль",
            RETURN_KW => "Вернуть",
            SUPER_KW => "базовый",
            SWITCH_KW => "ВыборПо",
            STATIC_KW => "статический",
            THIS_KW => "этот",
            THROW_KW => "ВызватьИсключение",
            TRY_KW => "Попытка",
            TRUE_KW => "истина",
            VAR_KW => "перем",
            WHILE_KW => "Пока",
            AND_KW => "и",
            OR_KW => "или",
            CONSTRUCTOR_KW => "Конструктор",
            GET_KW => "получить",
            SET_KW => "установить",
            K_KW => "к",
            _ => return None,
        };
        Some(tok)
    }
}
#[doc = r" Utility macro for creating a SyntaxKind through simple macro syntax"]
#[macro_export]
macro_rules ! T { [;] => { $crate :: MSyntaxKind :: SEMICOLON } ; [,] => { $crate :: MSyntaxKind :: COMMA } ; ['('] => { $crate :: MSyntaxKind :: L_PAREN } ; [')'] => { $crate :: MSyntaxKind :: R_PAREN } ; ['{'] => { $crate :: MSyntaxKind :: L_CURLY } ; ['}'] => { $crate :: MSyntaxKind :: R_CURLY } ; ['['] => { $crate :: MSyntaxKind :: L_BRACK } ; [']'] => { $crate :: MSyntaxKind :: R_BRACK } ; [<] => { $crate :: MSyntaxKind :: L_ANGLE } ; [>] => { $crate :: MSyntaxKind :: R_ANGLE } ; [?] => { $crate :: MSyntaxKind :: QUESTION } ; [&] => { $crate :: MSyntaxKind :: AMP } ; [|] => { $crate :: MSyntaxKind :: PIPE } ; [+] => { $crate :: MSyntaxKind :: PLUS } ; [++] => { $crate :: MSyntaxKind :: PLUS2 } ; [*] => { $crate :: MSyntaxKind :: STAR } ; [/] => { $crate :: MSyntaxKind :: SLASH } ; [^] => { $crate :: MSyntaxKind :: CARET } ; [%] => { $crate :: MSyntaxKind :: PERCENT } ; [.] => { $crate :: MSyntaxKind :: DOT } ; [...] => { $crate :: MSyntaxKind :: DOT3 } ; [:] => { $crate :: MSyntaxKind :: COLON } ; [=] => { $crate :: MSyntaxKind :: EQ } ; [==] => { $crate :: MSyntaxKind :: EQ2 } ; [!] => { $crate :: MSyntaxKind :: BANG } ; [!=] => { $crate :: MSyntaxKind :: NEQ } ; [-] => { $crate :: MSyntaxKind :: MINUS } ; [--] => { $crate :: MSyntaxKind :: MINUS2 } ; [<=] => { $crate :: MSyntaxKind :: LTEQ } ; [>=] => { $crate :: MSyntaxKind :: GTEQ } ; [+=] => { $crate :: MSyntaxKind :: PLUSEQ } ; [-=] => { $crate :: MSyntaxKind :: MINUSEQ } ; [/=] => { $crate :: MSyntaxKind :: SLASHEQ } ; [*=] => { $crate :: MSyntaxKind :: STAREQ } ; [%=] => { $crate :: MSyntaxKind :: PERCENTEQ } ; [&&] => { $crate :: MSyntaxKind :: AMP2 } ; [||] => { $crate :: MSyntaxKind :: PIPE2 } ; [@] => { $crate :: MSyntaxKind :: AT } ; ['`'] => { $crate :: MSyntaxKind :: BACKTICK } ; [break] => { $crate :: MSyntaxKind :: BREAK_KW } ; [case] => { $crate :: MSyntaxKind :: CASE_KW } ; [catch] => { $crate :: MSyntaxKind :: CATCH_KW } ; [class] => { $crate :: MSyntaxKind :: CLASS_KW } ; [k] => { $crate :: MSyntaxKind :: K_KW } ; [continue] => { $crate :: MSyntaxKind :: CONTINUE_KW } ; [debug] => { $crate :: MSyntaxKind :: DEBUG_KW } ;  [delete] => { $crate :: MSyntaxKind :: DELETE_KW } ; [do] => { $crate :: MSyntaxKind :: DO_KW } ; [else] => { $crate :: MSyntaxKind :: ELSE_KW } ; [extends] => { $crate :: MSyntaxKind :: EXTENDS_KW } ; [false] => { $crate :: MSyntaxKind :: FALSE_KW } ; [finally] => { $crate :: MSyntaxKind :: FINALLY_KW } ; [for] => { $crate :: MSyntaxKind :: FOR_KW } ; [forall] => { $crate :: MSyntaxKind :: FORALL_KW } ; [function] => { $crate :: MSyntaxKind :: FUNCTION_KW } ; [if] => { $crate :: MSyntaxKind :: IF_KW } ; [in] => { $crate :: MSyntaxKind :: IN_KW } ; [in2] => { $crate :: MSyntaxKind :: IN2_KW } ; [include] => { $crate :: MSyntaxKind :: INCLUDE_IN_KW } ; [new] => { $crate :: MSyntaxKind :: NEW_KW } ; [null] => { $crate :: MSyntaxKind :: NULL_KW } ; [return] => { $crate :: MSyntaxKind :: RETURN_KW } ; [super] => { $crate :: MSyntaxKind :: SUPER_KW } ; [switch] => { $crate :: MSyntaxKind :: SWITCH_KW } ; [this] => { $crate :: MSyntaxKind :: THIS_KW } ; [throw] => { $crate :: MSyntaxKind :: THROW_KW } ; [try] => { $crate :: MSyntaxKind :: TRY_KW } ; [true] => { $crate :: MSyntaxKind :: TRUE_KW } ; [var] => { $crate :: MSyntaxKind :: VAR_KW } ; [while] => { $crate :: MSyntaxKind :: WHILE_KW } ; [and] => { $crate :: MSyntaxKind :: AND_KW } ; [or] => { $crate :: MSyntaxKind :: OR_KW } ; [constructor] => { $crate :: MSyntaxKind :: CONSTRUCTOR_KW } ; [get] => { $crate :: MSyntaxKind :: GET_KW } ; [set] => { $crate :: MSyntaxKind :: SET_KW } ; [ident] => { $crate :: MSyntaxKind :: IDENT } ; [EOF] => { $crate :: MSyntaxKind :: EOF } ; [UNICODE_BOM] => { $crate :: MSyntaxKind :: UNICODE_BOM } ; [#] => { $crate :: MSyntaxKind :: HASH } ; [version] => { $ crate :: MSyntaxKind :: VERSION_KW } ; [static] => { $ crate :: MSyntaxKind :: STATIC_KW } ; [ff] => { $ crate :: MSyntaxKind :: FF } ; [ff2] => { $ crate :: MSyntaxKind :: FF2 } ; [inline] => { $ crate :: MSyntaxKind :: INLINE_KW } ;  [classof] => { $ crate :: MSyntaxKind :: CLASSOF_KW } ; [instanceof] => { $ crate :: MSyntaxKind :: INSTANCEOF_KW } ; }
