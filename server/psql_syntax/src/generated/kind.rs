//! Generated file, do not edit by hand, see `xtask/codegen`

#![allow(bad_style, missing_docs, unreachable_pub)]
#[doc = r" The kind of syntax node, e.g. `IDENT`, `FUNCTION_KW`, or `FOR_STMT`."]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
#[repr(u16)]
pub enum PsqlSyntaxKind {
    #[doc(hidden)]
    TOMBSTONE,
    #[doc = r" Marks the end of the file. May have trivia attached"]
    EOF,
    #[doc = r" Any Unicode BOM character that may be present at the start of"]
    #[doc = r" a file."]
    UNICODE_BOM,
    SEMICOLON,
    COMMA,
    L_PAREN,
    R_PAREN,
    L_CURLY,
    R_CURLY,
    L_BRACK,
    R_BRACK,
    L_ANGLE,
    R_ANGLE,
    TILDE,
    QUESTION,
    AMP,
    PIPE,
    PLUS,
    STAR,
    SLASH,
    CARET,
    PERCENT,
    DOT,
    COLON,
    EQ,
    BANG,
    NEQ,
    MINUS,
    LTEQ,
    GTEQ,
    INTEGER_KW,
    BIGINT_KW,
    VARCHAR_KW,
    CHAR_KW,
    TEXT_KW,
    BOOLEAN_KW,
    DATE_KW,
    TIME_KW,
    TIMESTAMP_KW,
    INTERVAL_KW,
    NUMERIC_KW,
    DECIMAL_KW,
    DOUBLE_KW,
    REAL_KW,
    JSON_KW,
    JSONB_KW,
    UUID_KW,
    ARRAY_KW,
    BYTEA_KW,
    BIT_KW,
    CREATE_KW,
    ALTER_KW,
    DROP_KW,
    TABLE_KW,
    VIEW_KW,
    INDEX_KW,
    SEQUENCE_KW,
    SCHEMA_KW,
    DATABASE_KW,
    CONSTRAINT_KW,
    UNIQUE_KW,
    PRIMARY_KW,
    FOREIGN_KW,
    KEY_KW,
    CHECK_KW,
    DEFAULT_KW,
    INSERT_KW,
    UPDATE_KW,
    DELETE_KW,
    SELECT_KW,
    FROM_KW,
    WHERE_KW,
    GROUP_BY_KW,
    ORDER_BY_KW,
    HAVING_KW,
    VALUES_KW,
    SET_KW,
    INNER_KW,
    OUTER_KW,
    LEFT_KW,
    RIGHT_KW,
    JOIN_KW,
    ON_KW,
    USING_KW,
    AS_KW,
    LIMIT_KW,
    OFFSET_KW,
    INTO_KW,
    DISTINCT_KW,
    CASE_KW,
    WHEN_KW,
    THEN_KW,
    END_KW,
    IF_KW,
    ELSE_KW,
    AND_KW,
    OR_KW,
    NOT_KW,
    BETWEEN_KW,
    IN_KW,
    LIKE_KW,
    ILIKE_KW,
    IS_KW,
    ASC_KW,
    DESC_KW,
    UNION_KW,
    INTERSECT_KW,
    EXCEPT_KW,
    OVER_KW,
    PARTITION_KW,
    BEGIN_KW,
    COMMIT_KW,
    ROLLBACK_KW,
    START_KW,
    NULL_KW,
    TRUE_KW,
    FALSE_KW,
    PSQL_NUMBER_LITERAL,
    PSQL_STRING_LITERAL,
    ERROR_TOKEN,
    IDENT,
    NEWLINE,
    WHITESPACE,
    COMMENT,
    PSQL_ROOT,
    PSQL_STMT_LIST,
    PSQL_SELECT_STMT,
    PSQL_SELECT_CLAUSE,
    PSQL_SELECT_ITEM_LIST,
    PSQL_SELECT_ITEM,
    PSQL_FROM_CLAUSE,
    PSQL_WHERE_CLAUSE,
    PSQL_GROUP_BY_CLAUSE,
    PSQL_GROUP_BY_ITEM_LIST,
    PSQL_HAVING_CLAUSE,
    PSQL_ORDER_BY_CLAUSE,
    PSQL_ORDER_BY_EXPRESSION_LIST,
    PSQL_ORDER_BY_EXPRESSION,
    PSQL_OFFSET_CLAUSE,
    PSQL_LIMIT_CLAUSE,
    PSQL_INSERT_STMT,
    PSQL_INSERT_COLUMNS,
    PSQL_INSERT_COLUMN_LIST,
    PSQL_INSERT_VALUES,
    PSQL_DELETE_STMT,
    PSQL_DELETE_USING_CLAUSE,
    PSQL_UPDATE_STMT,
    PSQL_SET_CLAUSE,
    PSQL_SET_ITEM_LIST,
    PSQL_SET_ITEM,
    PSQL_DATA_BASE_NAME,
    PSQL_SHEMA_NAME,
    PSQL_TABLE_NAME,
    PSQL_TABLE_BINDING,
    PSQL_FUNCTION_BINDING,
    PSQL_NAME,
    PSQL_STAR,
    PSQL_ALIAS,
    PSQL_SUB_QUERY,
    PSQL_EXPRESSION_LIST,
    PSQL_TABLE_COL_REFERENCE,
    PSQL_COL_REFERENCE,
    PSQL_BINARY_EXPRESSION,
    PSQL_LOGICAL_EXPRESSION,
    PSQL_PARENTHESIZED_EXPRESSION,
    PSQL_NUMBER_LITERAL_EXPRESSION,
    PSQL_STRING_LITERAL_EXPRESSION,
    PSQL_NULL_LITERAL_EXPRESSION,
    PSQL_BOOLEAN_LITERAL_EXPRESSION,
    PSQL_BOGUS,
    PSQL_BOGUS_EXPRESSION,
    PSQL_BOGUS_STATEMENT,
    PSQL_BOGUS_MEMBER,
    PSQL_BOGUS_BINDING,
    PSQL_BOGUS_PARAMETER,
    PSQL_BOGUS_ASSIGNMENT,
    #[doc(hidden)]
    __LAST,
}
use self::PsqlSyntaxKind::*;
impl PsqlSyntaxKind {
    pub const fn is_punct(self) -> bool {
        matches!(
            self,
            SEMICOLON
                | COMMA
                | L_PAREN
                | R_PAREN
                | L_CURLY
                | R_CURLY
                | L_BRACK
                | R_BRACK
                | L_ANGLE
                | R_ANGLE
                | TILDE
                | QUESTION
                | AMP
                | PIPE
                | PLUS
                | STAR
                | SLASH
                | CARET
                | PERCENT
                | DOT
                | COLON
                | EQ
                | BANG
                | NEQ
                | MINUS
                | LTEQ
                | GTEQ
        )
    }
    pub const fn is_literal(self) -> bool {
        matches!(self, PSQL_NUMBER_LITERAL | PSQL_STRING_LITERAL)
    }
    pub const fn is_list(self) -> bool {
        matches!(
            self,
            PSQL_STMT_LIST
                | PSQL_SELECT_ITEM_LIST
                | PSQL_GROUP_BY_ITEM_LIST
                | PSQL_ORDER_BY_EXPRESSION_LIST
                | PSQL_INSERT_COLUMN_LIST
                | PSQL_SET_ITEM_LIST
                | PSQL_EXPRESSION_LIST
        )
    }
    pub fn from_keyword(ident: &str) -> Option<Self> {
        let kw = match ident {
            "integer" => INTEGER_KW,
            "bigint" => BIGINT_KW,
            "varchar" => VARCHAR_KW,
            "char" => CHAR_KW,
            "text" => TEXT_KW,
            "boolean" => BOOLEAN_KW,
            "date" => DATE_KW,
            "time" => TIME_KW,
            "timestamp" => TIMESTAMP_KW,
            "interval" => INTERVAL_KW,
            "numeric" => NUMERIC_KW,
            "decimal" => DECIMAL_KW,
            "double" => DOUBLE_KW,
            "real" => REAL_KW,
            "json" => JSON_KW,
            "jsonb" => JSONB_KW,
            "uuid" => UUID_KW,
            "array" => ARRAY_KW,
            "bytea" => BYTEA_KW,
            "bit" => BIT_KW,
            "create" => CREATE_KW,
            "alter" => ALTER_KW,
            "drop" => DROP_KW,
            "table" => TABLE_KW,
            "view" => VIEW_KW,
            "index" => INDEX_KW,
            "sequence" => SEQUENCE_KW,
            "schema" => SCHEMA_KW,
            "database" => DATABASE_KW,
            "constraint" => CONSTRAINT_KW,
            "unique" => UNIQUE_KW,
            "primary" => PRIMARY_KW,
            "foreign" => FOREIGN_KW,
            "key" => KEY_KW,
            "check" => CHECK_KW,
            "default" => DEFAULT_KW,
            "insert" => INSERT_KW,
            "update" => UPDATE_KW,
            "delete" => DELETE_KW,
            "select" => SELECT_KW,
            "from" => FROM_KW,
            "where" => WHERE_KW,
            "group_by" => GROUP_BY_KW,
            "order_by" => ORDER_BY_KW,
            "having" => HAVING_KW,
            "values" => VALUES_KW,
            "set" => SET_KW,
            "inner" => INNER_KW,
            "outer" => OUTER_KW,
            "left" => LEFT_KW,
            "right" => RIGHT_KW,
            "join" => JOIN_KW,
            "on" => ON_KW,
            "using" => USING_KW,
            "as" => AS_KW,
            "limit" => LIMIT_KW,
            "offset" => OFFSET_KW,
            "into" => INTO_KW,
            "distinct" => DISTINCT_KW,
            "case" => CASE_KW,
            "when" => WHEN_KW,
            "then" => THEN_KW,
            "end" => END_KW,
            "if" => IF_KW,
            "else" => ELSE_KW,
            "and" => AND_KW,
            "or" => OR_KW,
            "not" => NOT_KW,
            "between" => BETWEEN_KW,
            "in" => IN_KW,
            "like" => LIKE_KW,
            "ilike" => ILIKE_KW,
            "is" => IS_KW,
            "asc" => ASC_KW,
            "desc" => DESC_KW,
            "union" => UNION_KW,
            "intersect" => INTERSECT_KW,
            "except" => EXCEPT_KW,
            "over" => OVER_KW,
            "partition" => PARTITION_KW,
            "begin" => BEGIN_KW,
            "commit" => COMMIT_KW,
            "rollback" => ROLLBACK_KW,
            "start" => START_KW,
            "null" => NULL_KW,
            "true" => TRUE_KW,
            "false" => FALSE_KW,
            _ => return None,
        };
        Some(kw)
    }
    pub const fn to_string(&self) -> Option<&'static str> {
        let tok = match self {
            SEMICOLON => ";",
            COMMA => ",",
            L_PAREN => "(",
            R_PAREN => ")",
            L_CURLY => "{",
            R_CURLY => "}",
            L_BRACK => "[",
            R_BRACK => "]",
            L_ANGLE => "<",
            R_ANGLE => ">",
            TILDE => "~",
            QUESTION => "?",
            AMP => "&",
            PIPE => "|",
            PLUS => "+",
            STAR => "*",
            SLASH => "/",
            CARET => "^",
            PERCENT => "%",
            DOT => ".",
            COLON => ":",
            EQ => "=",
            BANG => "!",
            NEQ => "!=",
            MINUS => "-",
            LTEQ => "<=",
            GTEQ => ">=",
            INTEGER_KW => "integer",
            BIGINT_KW => "bigint",
            VARCHAR_KW => "varchar",
            CHAR_KW => "char",
            TEXT_KW => "text",
            BOOLEAN_KW => "boolean",
            DATE_KW => "date",
            TIME_KW => "time",
            TIMESTAMP_KW => "timestamp",
            INTERVAL_KW => "interval",
            NUMERIC_KW => "numeric",
            DECIMAL_KW => "decimal",
            DOUBLE_KW => "double",
            REAL_KW => "real",
            JSON_KW => "json",
            JSONB_KW => "jsonb",
            UUID_KW => "uuid",
            ARRAY_KW => "array",
            BYTEA_KW => "bytea",
            BIT_KW => "bit",
            CREATE_KW => "create",
            ALTER_KW => "alter",
            DROP_KW => "drop",
            TABLE_KW => "table",
            VIEW_KW => "view",
            INDEX_KW => "index",
            SEQUENCE_KW => "sequence",
            SCHEMA_KW => "schema",
            DATABASE_KW => "database",
            CONSTRAINT_KW => "constraint",
            UNIQUE_KW => "unique",
            PRIMARY_KW => "primary",
            FOREIGN_KW => "foreign",
            KEY_KW => "key",
            CHECK_KW => "check",
            DEFAULT_KW => "default",
            INSERT_KW => "insert",
            UPDATE_KW => "update",
            DELETE_KW => "delete",
            SELECT_KW => "select",
            FROM_KW => "from",
            WHERE_KW => "where",
            GROUP_BY_KW => "group_by",
            ORDER_BY_KW => "order_by",
            HAVING_KW => "having",
            VALUES_KW => "values",
            SET_KW => "set",
            INNER_KW => "inner",
            OUTER_KW => "outer",
            LEFT_KW => "left",
            RIGHT_KW => "right",
            JOIN_KW => "join",
            ON_KW => "on",
            USING_KW => "using",
            AS_KW => "as",
            LIMIT_KW => "limit",
            OFFSET_KW => "offset",
            INTO_KW => "into",
            DISTINCT_KW => "distinct",
            CASE_KW => "case",
            WHEN_KW => "when",
            THEN_KW => "then",
            END_KW => "end",
            IF_KW => "if",
            ELSE_KW => "else",
            AND_KW => "and",
            OR_KW => "or",
            NOT_KW => "not",
            BETWEEN_KW => "between",
            IN_KW => "in",
            LIKE_KW => "like",
            ILIKE_KW => "ilike",
            IS_KW => "is",
            ASC_KW => "asc",
            DESC_KW => "desc",
            UNION_KW => "union",
            INTERSECT_KW => "intersect",
            EXCEPT_KW => "except",
            OVER_KW => "over",
            PARTITION_KW => "partition",
            BEGIN_KW => "begin",
            COMMIT_KW => "commit",
            ROLLBACK_KW => "rollback",
            START_KW => "start",
            NULL_KW => "null",
            TRUE_KW => "true",
            FALSE_KW => "false",
            PSQL_STRING_LITERAL => "string literal",
            _ => return None,
        };
        Some(tok)
    }
}
#[doc = r" Utility macro for creating a SyntaxKind through simple macro syntax"]
#[macro_export]
macro_rules ! T { [;] => { $ crate :: PsqlSyntaxKind :: SEMICOLON } ; [,] => { $ crate :: PsqlSyntaxKind :: COMMA } ; ['('] => { $ crate :: PsqlSyntaxKind :: L_PAREN } ; [')'] => { $ crate :: PsqlSyntaxKind :: R_PAREN } ; ['{'] => { $ crate :: PsqlSyntaxKind :: L_CURLY } ; ['}'] => { $ crate :: PsqlSyntaxKind :: R_CURLY } ; ['['] => { $ crate :: PsqlSyntaxKind :: L_BRACK } ; [']'] => { $ crate :: PsqlSyntaxKind :: R_BRACK } ; [<] => { $ crate :: PsqlSyntaxKind :: L_ANGLE } ; [>] => { $ crate :: PsqlSyntaxKind :: R_ANGLE } ; [~] => { $ crate :: PsqlSyntaxKind :: TILDE } ; [?] => { $ crate :: PsqlSyntaxKind :: QUESTION } ; [&] => { $ crate :: PsqlSyntaxKind :: AMP } ; [|] => { $ crate :: PsqlSyntaxKind :: PIPE } ; [+] => { $ crate :: PsqlSyntaxKind :: PLUS } ; [*] => { $ crate :: PsqlSyntaxKind :: STAR } ; [/] => { $ crate :: PsqlSyntaxKind :: SLASH } ; [^] => { $ crate :: PsqlSyntaxKind :: CARET } ; [%] => { $ crate :: PsqlSyntaxKind :: PERCENT } ; [.] => { $ crate :: PsqlSyntaxKind :: DOT } ; [:] => { $ crate :: PsqlSyntaxKind :: COLON } ; [=] => { $ crate :: PsqlSyntaxKind :: EQ } ; [!] => { $ crate :: PsqlSyntaxKind :: BANG } ; [!=] => { $ crate :: PsqlSyntaxKind :: NEQ } ; [-] => { $ crate :: PsqlSyntaxKind :: MINUS } ; [<=] => { $ crate :: PsqlSyntaxKind :: LTEQ } ; [>=] => { $ crate :: PsqlSyntaxKind :: GTEQ } ; [integer] => { $ crate :: PsqlSyntaxKind :: INTEGER_KW } ; [bigint] => { $ crate :: PsqlSyntaxKind :: BIGINT_KW } ; [varchar] => { $ crate :: PsqlSyntaxKind :: VARCHAR_KW } ; [char] => { $ crate :: PsqlSyntaxKind :: CHAR_KW } ; [text] => { $ crate :: PsqlSyntaxKind :: TEXT_KW } ; [boolean] => { $ crate :: PsqlSyntaxKind :: BOOLEAN_KW } ; [date] => { $ crate :: PsqlSyntaxKind :: DATE_KW } ; [time] => { $ crate :: PsqlSyntaxKind :: TIME_KW } ; [timestamp] => { $ crate :: PsqlSyntaxKind :: TIMESTAMP_KW } ; [interval] => { $ crate :: PsqlSyntaxKind :: INTERVAL_KW } ; [numeric] => { $ crate :: PsqlSyntaxKind :: NUMERIC_KW } ; [decimal] => { $ crate :: PsqlSyntaxKind :: DECIMAL_KW } ; [double] => { $ crate :: PsqlSyntaxKind :: DOUBLE_KW } ; [real] => { $ crate :: PsqlSyntaxKind :: REAL_KW } ; [json] => { $ crate :: PsqlSyntaxKind :: JSON_KW } ; [jsonb] => { $ crate :: PsqlSyntaxKind :: JSONB_KW } ; [uuid] => { $ crate :: PsqlSyntaxKind :: UUID_KW } ; [array] => { $ crate :: PsqlSyntaxKind :: ARRAY_KW } ; [bytea] => { $ crate :: PsqlSyntaxKind :: BYTEA_KW } ; [bit] => { $ crate :: PsqlSyntaxKind :: BIT_KW } ; [create] => { $ crate :: PsqlSyntaxKind :: CREATE_KW } ; [alter] => { $ crate :: PsqlSyntaxKind :: ALTER_KW } ; [drop] => { $ crate :: PsqlSyntaxKind :: DROP_KW } ; [table] => { $ crate :: PsqlSyntaxKind :: TABLE_KW } ; [view] => { $ crate :: PsqlSyntaxKind :: VIEW_KW } ; [index] => { $ crate :: PsqlSyntaxKind :: INDEX_KW } ; [sequence] => { $ crate :: PsqlSyntaxKind :: SEQUENCE_KW } ; [schema] => { $ crate :: PsqlSyntaxKind :: SCHEMA_KW } ; [database] => { $ crate :: PsqlSyntaxKind :: DATABASE_KW } ; [constraint] => { $ crate :: PsqlSyntaxKind :: CONSTRAINT_KW } ; [unique] => { $ crate :: PsqlSyntaxKind :: UNIQUE_KW } ; [primary] => { $ crate :: PsqlSyntaxKind :: PRIMARY_KW } ; [foreign] => { $ crate :: PsqlSyntaxKind :: FOREIGN_KW } ; [key] => { $ crate :: PsqlSyntaxKind :: KEY_KW } ; [check] => { $ crate :: PsqlSyntaxKind :: CHECK_KW } ; [default] => { $ crate :: PsqlSyntaxKind :: DEFAULT_KW } ; [insert] => { $ crate :: PsqlSyntaxKind :: INSERT_KW } ; [update] => { $ crate :: PsqlSyntaxKind :: UPDATE_KW } ; [delete] => { $ crate :: PsqlSyntaxKind :: DELETE_KW } ; [select] => { $ crate :: PsqlSyntaxKind :: SELECT_KW } ; [from] => { $ crate :: PsqlSyntaxKind :: FROM_KW } ; [where] => { $ crate :: PsqlSyntaxKind :: WHERE_KW } ; [group_by] => { $ crate :: PsqlSyntaxKind :: GROUP_BY_KW } ; [order_by] => { $ crate :: PsqlSyntaxKind :: ORDER_BY_KW } ; [having] => { $ crate :: PsqlSyntaxKind :: HAVING_KW } ; [values] => { $ crate :: PsqlSyntaxKind :: VALUES_KW } ; [set] => { $ crate :: PsqlSyntaxKind :: SET_KW } ; [inner] => { $ crate :: PsqlSyntaxKind :: INNER_KW } ; [outer] => { $ crate :: PsqlSyntaxKind :: OUTER_KW } ; [left] => { $ crate :: PsqlSyntaxKind :: LEFT_KW } ; [right] => { $ crate :: PsqlSyntaxKind :: RIGHT_KW } ; [join] => { $ crate :: PsqlSyntaxKind :: JOIN_KW } ; [on] => { $ crate :: PsqlSyntaxKind :: ON_KW } ; [using] => { $ crate :: PsqlSyntaxKind :: USING_KW } ; [as] => { $ crate :: PsqlSyntaxKind :: AS_KW } ; [limit] => { $ crate :: PsqlSyntaxKind :: LIMIT_KW } ; [offset] => { $ crate :: PsqlSyntaxKind :: OFFSET_KW } ; [into] => { $ crate :: PsqlSyntaxKind :: INTO_KW } ; [distinct] => { $ crate :: PsqlSyntaxKind :: DISTINCT_KW } ; [case] => { $ crate :: PsqlSyntaxKind :: CASE_KW } ; [when] => { $ crate :: PsqlSyntaxKind :: WHEN_KW } ; [then] => { $ crate :: PsqlSyntaxKind :: THEN_KW } ; [end] => { $ crate :: PsqlSyntaxKind :: END_KW } ; [if] => { $ crate :: PsqlSyntaxKind :: IF_KW } ; [else] => { $ crate :: PsqlSyntaxKind :: ELSE_KW } ; [and] => { $ crate :: PsqlSyntaxKind :: AND_KW } ; [or] => { $ crate :: PsqlSyntaxKind :: OR_KW } ; [not] => { $ crate :: PsqlSyntaxKind :: NOT_KW } ; [between] => { $ crate :: PsqlSyntaxKind :: BETWEEN_KW } ; [in] => { $ crate :: PsqlSyntaxKind :: IN_KW } ; [like] => { $ crate :: PsqlSyntaxKind :: LIKE_KW } ; [ilike] => { $ crate :: PsqlSyntaxKind :: ILIKE_KW } ; [is] => { $ crate :: PsqlSyntaxKind :: IS_KW } ; [asc] => { $ crate :: PsqlSyntaxKind :: ASC_KW } ; [desc] => { $ crate :: PsqlSyntaxKind :: DESC_KW } ; [union] => { $ crate :: PsqlSyntaxKind :: UNION_KW } ; [intersect] => { $ crate :: PsqlSyntaxKind :: INTERSECT_KW } ; [except] => { $ crate :: PsqlSyntaxKind :: EXCEPT_KW } ; [over] => { $ crate :: PsqlSyntaxKind :: OVER_KW } ; [partition] => { $ crate :: PsqlSyntaxKind :: PARTITION_KW } ; [begin] => { $ crate :: PsqlSyntaxKind :: BEGIN_KW } ; [commit] => { $ crate :: PsqlSyntaxKind :: COMMIT_KW } ; [rollback] => { $ crate :: PsqlSyntaxKind :: ROLLBACK_KW } ; [start] => { $ crate :: PsqlSyntaxKind :: START_KW } ; [null] => { $ crate :: PsqlSyntaxKind :: NULL_KW } ; [true] => { $ crate :: PsqlSyntaxKind :: TRUE_KW } ; [false] => { $ crate :: PsqlSyntaxKind :: FALSE_KW } ; [ident] => { $ crate :: PsqlSyntaxKind :: IDENT } ; [EOF] => { $ crate :: PsqlSyntaxKind :: EOF } ; [UNICODE_BOM] => { $ crate :: PsqlSyntaxKind :: UNICODE_BOM } ; [#] => { $ crate :: PsqlSyntaxKind :: HASH } ; }
