//! Generated file, do not edit by hand, see `xtask/codegen`

#![allow(clippy::all)]
#![allow(bad_style, missing_docs, unreachable_pub)]
#[doc = r" The kind of syntax node, e.g. `IDENT`, `FUNCTION_KW`, or `FOR_STMT`."]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
#[repr(u16)]
pub enum MSyntaxKind {
    #[doc(hidden)]
    TOMBSTONE,
    #[doc = r" Marks the end of the file. May have trivia attached"]
    EOF,
    #[doc = r" Any Unicode BOM character that may be present at the start of"]
    #[doc = r" a file."]
    UNICODE_BOM,
    SEMICOLON,
    COMMA,
    L_PAREN,
    R_PAREN,
    L_CURLY,
    R_CURLY,
    L_BRACK,
    R_BRACK,
    L_ANGLE,
    R_ANGLE,
    TILDE,
    QUESTION,
    AMP,
    PIPE,
    PLUS,
    PLUS2,
    STAR,
    SLASH,
    CARET,
    PERCENT,
    DOT,
    DOT3,
    COLON,
    EQ,
    EQ2,
    BANG,
    NEQ,
    MINUS,
    MINUS2,
    LTEQ,
    GTEQ,
    PLUSEQ,
    MINUSEQ,
    SLASHEQ,
    STAREQ,
    PERCENTEQ,
    AMP2,
    PIPE2,
    AT,
    BACKTICK,
    BREAK_KW,
    CASE_KW,
    CATCH_KW,
    CLASS_KW,
    CONST_KW,
    CONTINUE_KW,
    DEBUG_KW,
    DEFAULT_KW,
    DELETE_KW,
    DO_KW,
    ELSE_KW,
    EXTENDS_KW,
    FALSE_KW,
    FINALLY_KW,
    FOR_KW,
    FORALL_KW,
    FUNCTION_KW,
    IF_KW,
    IN_KW,
    NEW_KW,
    NULL_KW,
    RETURN_KW,
    SUPER_KW,
    SWITCH_KW,
    THIS_KW,
    THROW_KW,
    TRY_KW,
    TRUE_KW,
    VAR_KW,
    WHILE_KW,
    AND_KW,
    OR_KW,
    CONSTRUCTOR_KW,
    GET_KW,
    SET_KW,
    M_NUMBER_LITERAL,
    M_BIGINT_LITERAL,
    M_STRING_LITERAL,
    M_LONG_STRING_LITERAL,
    ERROR_TOKEN,
    IDENT,
    NEWLINE,
    WHITESPACE,
    COMMENT,
    M_MODULE,
    M_MODULE_ITEM_LIST,
    M_SCRIPT,
    M_EXPRESSION_SNIPPED,
    M_DIRECTIVE,
    M_DIRECTIVE_LIST,
    M_STATEMENT_LIST,
    M_BLOCK_STATEMENT,
    M_FUNCTION_BODY,
    M_VARIABLE_STATEMENT,
    M_VARIABLE_DECLARATION,
    M_VARIABLE_DECLARATOR_LIST,
    M_VARIABLE_DECLARATOR,
    M_VARIABLE_DECLARATION_CLAUSE,
    M_INITIALIZER_CLAUSE,
    M_EMPTY_STATEMENT,
    M_EXPRESSION_STATEMENT,
    M_IF_STATEMENT,
    M_ELSE_CLAUSE,
    M_WHILE_STATEMENT,
    M_FOR_STATEMENT,
    M_FOR_IN_STATEMENT,
    M_FOR_ALL_STATEMENT,
    M_FOR_VARIABLE_DECLARATION,
    M_CONTINUE_STATEMENT,
    M_BREAK_STATEMENT,
    M_RETURN_STATEMENT,
    M_SWITCH_STATEMENT,
    M_SWITCH_CASE_LIST,
    M_CASE_CLAUSE,
    M_DEFAULT_CLAUSE,
    M_THROW_STATEMENT,
    M_TRY_STATEMENT,
    M_TRY_FINALLY_STATEMENT,
    M_CATCH_CLAUSE,
    M_CATCH_DECLARATION,
    M_FINALLY_CLAUSE,
    M_DEBUG_STATEMENT,
    M_FUNCTION_DECLARATION,
    M_PARAMETERS,
    M_PARAMETER_LIST,
    M_FORMAL_PARAMETER,
    M_REST_PARAMETER,
    M_ASSIGNMENT_PATTERN,
    M_BINDING_PATTERN,
    M_IDENTIFIER_BINDING,
    M_IDENTIFIER_EXPRESSION,
    M_REFERENCE_IDENTIFIER,
    M_NAME,
    M_PRIVATE_NAME,
    M_THIS_EXPRESSION,
    M_ARRAY_EXPRESSION,
    M_ARRAY_ELEMENT_LIST,
    M_ARRAY_HOLE,
    M_COMPUTED_MEMBER_NAME,
    M_LITERAL_MEMBER_NAME,
    M_OBJECT_EXPRESSION,
    M_OBJECT_MEMBER_LIST,
    M_PROPERTY_OBJECT_MEMBER,
    M_SUPER_EXPRESSION,
    M_PARENTHESIZED_EXPRESSION,
    M_NEW_EXPRESSION,
    M_FUNCTION_EXPRESSION,
    M_STATIC_MEMBER_EXPRESSION,
    M_COMPUTED_MEMBER_EXPRESSION,
    M_CALL_EXPRESSION,
    M_UNARY_EXPRESSION,
    M_PRE_UPDATE_EXPRESSION,
    M_POST_UPDATE_EXPRESSION,
    M_BINARY_EXPRESSION,
    M_IN_EXPRESSION,
    M_IN_PROPERTY,
    M_LOGICAL_EXPRESSION,
    M_CONDITIONAL_EXPRESSION,
    M_ASSIGNMENT_EXPRESSION,
    M_SEQUENCE_EXPRESSION,
    M_CALL_ARGUMENTS,
    M_CALL_ARGUMENT_LIST,
    M_STRING_LITERAL_EXPRESSION,
    M_NUMBER_LITERAL_EXPRESSION,
    M_BIGINT_LITERAL_EXPRESSION,
    M_BOOLEAN_LITERAL_EXPRESSION,
    M_NULL_LITERAL_EXPRESSION,
    M_LONG_STRING_LITERAL_EXPRESSION,
    M_TEMPLATE_EXPRESSION,
    M_TEMPLATE_ELEMENT,
    M_TEMPLATE_CHUNK_ELEMENT,
    M_TEMPLATE_ELEMENT_LIST,
    M_SHORTHAND_PROPERTY_OBJECT_MEMBER,
    M_SPREAD,
    M_CLASS,
    M_CLASS_DECLARATION,
    M_CLASS_EXPRESSION,
    M_CLASS_MEMBER_LIST,
    M_EXTENDS_CLAUSE,
    M_PRIVATE_CLASS_MEMBER_NAME,
    M_CONSTRUCTOR_CLASS_MEMBER,
    M_CONSTRUCTOR_MODIFIER_LIST,
    M_CONSTRUCTOR_PARAMETER_LIST,
    M_CONSTRUCTOR_PARAMETERS,
    M_PROPERTY_CLASS_MEMBER,
    M_PROPERTY_MODIFIER_LIST,
    M_METHOD_CLASS_MEMBER,
    M_METHOD_MODIFIER_LIST,
    M_GETTER_CLASS_MEMBER,
    M_SETTER_CLASS_MEMBER,
    M_EMPTY_CLASS_MEMBER,
    M_PARENTHESIZED_ASSIGNMENT,
    M_IDENTIFIER_ASSIGNMENT,
    M_STATIC_MEMBER_ASSIGNMENT,
    M_COMPUTED_MEMBER_ASSIGNMENT,
    M_BOGUS,
    M_BOGUS_EXPRESSION,
    M_BOGUS_STATEMENT,
    M_BOGUS_MEMBER,
    M_BOGUS_BINDING,
    M_BOGUS_PARAMETER,
    M_BOGUS_ASSIGNMENT,
    #[doc(hidden)]
    __LAST,
}
use self::MSyntaxKind::*;
impl MSyntaxKind {
    pub const fn is_punct(self) -> bool {
        match self {
            SEMICOLON | COMMA | L_PAREN | R_PAREN | L_CURLY | R_CURLY | L_BRACK | R_BRACK
            | L_ANGLE | R_ANGLE | TILDE | QUESTION | AMP | PIPE | PLUS | PLUS2 | STAR | SLASH
            | CARET | PERCENT | DOT | DOT3 | COLON | EQ | EQ2 | BANG | NEQ | MINUS | MINUS2
            | LTEQ | GTEQ | PLUSEQ | MINUSEQ | SLASHEQ | STAREQ | PERCENTEQ | AMP2 | PIPE2 | AT
            | BACKTICK => true,
            _ => false,
        }
    }
    pub const fn is_literal(self) -> bool {
        match self {
            M_NUMBER_LITERAL | M_BIGINT_LITERAL | M_STRING_LITERAL | M_LONG_STRING_LITERAL => true,
            _ => false,
        }
    }
    pub const fn is_list(self) -> bool {
        match self {
            M_MODULE_ITEM_LIST
            | M_DIRECTIVE_LIST
            | M_STATEMENT_LIST
            | M_VARIABLE_DECLARATOR_LIST
            | M_SWITCH_CASE_LIST
            | M_PARAMETER_LIST
            | M_ARRAY_ELEMENT_LIST
            | M_OBJECT_MEMBER_LIST
            | M_CALL_ARGUMENT_LIST
            | M_TEMPLATE_ELEMENT_LIST
            | M_CLASS_MEMBER_LIST
            | M_CONSTRUCTOR_MODIFIER_LIST
            | M_CONSTRUCTOR_PARAMETER_LIST
            | M_PROPERTY_MODIFIER_LIST
            | M_METHOD_MODIFIER_LIST => true,
            _ => false,
        }
    }
    pub fn from_keyword(ident: &str) -> Option<MSyntaxKind> {
        let kw = match ident {
            "break" => BREAK_KW,
            "case" => CASE_KW,
            "catch" => CATCH_KW,
            "class" => CLASS_KW,
            "const" => CONST_KW,
            "continue" => CONTINUE_KW,
            "debug" => DEBUG_KW,
            "default" => DEFAULT_KW,
            "delete" => DELETE_KW,
            "else" => ELSE_KW,
            "extends" => EXTENDS_KW,
            "false" => FALSE_KW,
            "finally" => FINALLY_KW,
            "for" => FOR_KW,
            "forall" => FORALL_KW,
            "func" => FUNCTION_KW,
            "if" => IF_KW,
            "in" => IN_KW,
            "new" => NEW_KW,
            "null" => NULL_KW,
            "return" => RETURN_KW,
            "super" => SUPER_KW,
            "switch" => SWITCH_KW,
            "this" => THIS_KW,
            "throw" => THROW_KW,
            "try" => TRY_KW,
            "true" => TRUE_KW,
            "var" => VAR_KW,
            "while" => WHILE_KW,
            "and" => AND_KW,
            "or" => OR_KW,
            "constructor" => CONSTRUCTOR_KW,
            "get" => GET_KW,
            "set" => SET_KW,
            _ => return None,
        };
        Some(kw)
    }
    pub const fn to_string(&self) -> Option<&'static str> {
        let tok = match self {
            SEMICOLON => ";",
            COMMA => ",",
            L_PAREN => "(",
            R_PAREN => ")",
            L_CURLY => "{",
            R_CURLY => "}",
            L_BRACK => "[",
            R_BRACK => "]",
            L_ANGLE => "<",
            R_ANGLE => ">",
            TILDE => "~",
            QUESTION => "?",
            AMP => "&",
            PIPE => "|",
            PLUS => "+",
            PLUS2 => "++",
            STAR => "*",
            SLASH => "/",
            CARET => "^",
            PERCENT => "%",
            DOT => ".",
            DOT3 => "...",
            COLON => ":",
            EQ => "=",
            EQ2 => "==",
            BANG => "!",
            NEQ => "!=",
            MINUS => "-",
            MINUS2 => "--",
            LTEQ => "<=",
            GTEQ => ">=",
            PLUSEQ => "+=",
            MINUSEQ => "-=",
            SLASHEQ => "/=",
            STAREQ => "*=",
            PERCENTEQ => "%=",
            AMP2 => "&&",
            PIPE2 => "||",
            AT => "@",
            BACKTICK => "`",
            BREAK_KW => "break",
            CASE_KW => "case",
            CATCH_KW => "catch",
            CLASS_KW => "class",
            CONST_KW => "const",
            CONTINUE_KW => "continue",
            DEBUG_KW => "debug",
            DEFAULT_KW => "default",
            DELETE_KW => "delete",
            DO_KW => "do",
            ELSE_KW => "else",
            EXTENDS_KW => "extends",
            FALSE_KW => "false",
            FINALLY_KW => "finally",
            FOR_KW => "for",
            FORALL_KW => "forall",
            FUNCTION_KW => "function",
            IF_KW => "if",
            IN_KW => "in",
            NEW_KW => "new",
            NULL_KW => "null",
            RETURN_KW => "return",
            SUPER_KW => "super",
            SWITCH_KW => "switch",
            THIS_KW => "this",
            THROW_KW => "throw",
            TRY_KW => "try",
            TRUE_KW => "true",
            VAR_KW => "var",
            WHILE_KW => "while",
            AND_KW => "and",
            OR_KW => "or",
            CONSTRUCTOR_KW => "constructor",
            GET_KW => "get",
            SET_KW => "set",
            M_STRING_LITERAL => "string literal",
            _ => return None,
        };
        Some(tok)
    }
}
#[doc = r" Utility macro for creating a SyntaxKind through simple macro syntax"]
#[macro_export]
macro_rules ! T { [;] => { crate :: m_lang :: syntax :: MSyntaxKind :: SEMICOLON } ; [,] => { crate :: m_lang :: syntax :: MSyntaxKind :: COMMA } ; ['('] => { crate :: m_lang :: syntax :: MSyntaxKind :: L_PAREN } ; [')'] => { crate :: m_lang :: syntax :: MSyntaxKind :: R_PAREN } ; ['{'] => { crate :: m_lang :: syntax :: MSyntaxKind :: L_CURLY } ; ['}'] => { crate :: m_lang :: syntax :: MSyntaxKind :: R_CURLY } ; ['['] => { crate :: m_lang :: syntax :: MSyntaxKind :: L_BRACK } ; [']'] => { crate :: m_lang :: syntax :: MSyntaxKind :: R_BRACK } ; [<] => { crate :: m_lang :: syntax :: MSyntaxKind :: L_ANGLE } ; [>] => { crate :: m_lang :: syntax :: MSyntaxKind :: R_ANGLE } ; [~] => { crate :: m_lang :: syntax :: MSyntaxKind :: TILDE } ; [?] => { crate :: m_lang :: syntax :: MSyntaxKind :: QUESTION } ; [&] => { crate :: m_lang :: syntax :: MSyntaxKind :: AMP } ; [|] => { crate :: m_lang :: syntax :: MSyntaxKind :: PIPE } ; [+] => { crate :: m_lang :: syntax :: MSyntaxKind :: PLUS } ; [++] => { crate :: m_lang :: syntax :: MSyntaxKind :: PLUS2 } ; [*] => { crate :: m_lang :: syntax :: MSyntaxKind :: STAR } ; [/] => { crate :: m_lang :: syntax :: MSyntaxKind :: SLASH } ; [^] => { crate :: m_lang :: syntax :: MSyntaxKind :: CARET } ; [%] => { crate :: m_lang :: syntax :: MSyntaxKind :: PERCENT } ; [.] => { crate :: m_lang :: syntax :: MSyntaxKind :: DOT } ; [...] => { crate :: m_lang :: syntax :: MSyntaxKind :: DOT3 } ; [:] => { crate :: m_lang :: syntax :: MSyntaxKind :: COLON } ; [=] => { crate :: m_lang :: syntax :: MSyntaxKind :: EQ } ; [==] => { crate :: m_lang :: syntax :: MSyntaxKind :: EQ2 } ; [!] => { crate :: m_lang :: syntax :: MSyntaxKind :: BANG } ; [!=] => { crate :: m_lang :: syntax :: MSyntaxKind :: NEQ } ; [-] => { crate :: m_lang :: syntax :: MSyntaxKind :: MINUS } ; [--] => { crate :: m_lang :: syntax :: MSyntaxKind :: MINUS2 } ; [<=] => { crate :: m_lang :: syntax :: MSyntaxKind :: LTEQ } ; [>=] => { crate :: m_lang :: syntax :: MSyntaxKind :: GTEQ } ; [+=] => { crate :: m_lang :: syntax :: MSyntaxKind :: PLUSEQ } ; [-=] => { crate :: m_lang :: syntax :: MSyntaxKind :: MINUSEQ } ; [/=] => { crate :: m_lang :: syntax :: MSyntaxKind :: SLASHEQ } ; [*=] => { crate :: m_lang :: syntax :: MSyntaxKind :: STAREQ } ; [%=] => { crate :: m_lang :: syntax :: MSyntaxKind :: PERCENTEQ } ; [&&] => { crate :: m_lang :: syntax :: MSyntaxKind :: AMP2 } ; [||] => { crate :: m_lang :: syntax :: MSyntaxKind :: PIPE2 } ; [@] => { crate :: m_lang :: syntax :: MSyntaxKind :: AT } ; ['`'] => { crate :: m_lang :: syntax :: MSyntaxKind :: BACKTICK } ; [break] => { crate :: m_lang :: syntax :: MSyntaxKind :: BREAK_KW } ; [case] => { crate :: m_lang :: syntax :: MSyntaxKind :: CASE_KW } ; [catch] => { crate :: m_lang :: syntax :: MSyntaxKind :: CATCH_KW } ; [class] => { crate :: m_lang :: syntax :: MSyntaxKind :: CLASS_KW } ; [const] => { crate :: m_lang :: syntax :: MSyntaxKind :: CONST_KW } ; [continue] => { crate :: m_lang :: syntax :: MSyntaxKind :: CONTINUE_KW } ; [debug] => { crate :: m_lang :: syntax :: MSyntaxKind :: DEBUG_KW } ; [default] => { crate :: m_lang :: syntax :: MSyntaxKind :: DEFAULT_KW } ; [delete] => { crate :: m_lang :: syntax :: MSyntaxKind :: DELETE_KW } ; [do] => { crate :: m_lang :: syntax :: MSyntaxKind :: DO_KW } ; [else] => { crate :: m_lang :: syntax :: MSyntaxKind :: ELSE_KW } ; [extends] => { crate :: m_lang :: syntax :: MSyntaxKind :: EXTENDS_KW } ; [false] => { crate :: m_lang :: syntax :: MSyntaxKind :: FALSE_KW } ; [finally] => { crate :: m_lang :: syntax :: MSyntaxKind :: FINALLY_KW } ; [for] => { crate :: m_lang :: syntax :: MSyntaxKind :: FOR_KW } ; [forall] => { crate :: m_lang :: syntax :: MSyntaxKind :: FORALL_KW } ; [function] => { crate :: m_lang :: syntax :: MSyntaxKind :: FUNCTION_KW } ; [if] => { crate :: m_lang :: syntax :: MSyntaxKind :: IF_KW } ; [in] => { crate :: m_lang :: syntax :: MSyntaxKind :: IN_KW } ; [new] => { crate :: m_lang :: syntax :: MSyntaxKind :: NEW_KW } ; [null] => { crate :: m_lang :: syntax :: MSyntaxKind :: NULL_KW } ; [return] => { crate :: m_lang :: syntax :: MSyntaxKind :: RETURN_KW } ; [super] => { crate :: m_lang :: syntax :: MSyntaxKind :: SUPER_KW } ; [switch] => { crate :: m_lang :: syntax :: MSyntaxKind :: SWITCH_KW } ; [this] => { crate :: m_lang :: syntax :: MSyntaxKind :: THIS_KW } ; [throw] => { crate :: m_lang :: syntax :: MSyntaxKind :: THROW_KW } ; [try] => { crate :: m_lang :: syntax :: MSyntaxKind :: TRY_KW } ; [true] => { crate :: m_lang :: syntax :: MSyntaxKind :: TRUE_KW } ; [var] => { crate :: m_lang :: syntax :: MSyntaxKind :: VAR_KW } ; [while] => { crate :: m_lang :: syntax :: MSyntaxKind :: WHILE_KW } ; [and] => { crate :: m_lang :: syntax :: MSyntaxKind :: AND_KW } ; [or] => { crate :: m_lang :: syntax :: MSyntaxKind :: OR_KW } ; [constructor] => { crate :: m_lang :: syntax :: MSyntaxKind :: CONSTRUCTOR_KW } ; [get] => { crate :: m_lang :: syntax :: MSyntaxKind :: GET_KW } ; [set] => { crate :: m_lang :: syntax :: MSyntaxKind :: SET_KW } ; [ident] => { crate :: m_lang :: syntax :: MSyntaxKind :: IDENT } ; [EOF] => { crate :: m_lang :: syntax :: MSyntaxKind :: EOF } ; [UNICODE_BOM] => { crate :: m_lang :: syntax :: MSyntaxKind :: UNICODE_BOM } ; [#] => { crate :: m_lang :: syntax :: MSyntaxKind :: HASH } ; }
