// Psql Un-Grammar.
//
// This grammar specifies the structure of Rust's concrete syntax tree.
// It does not specify parsing rules (ambiguities, precedence, etc are out of scope).
// Tokens are processed -- contextual keywords are recognised, compound operators glued.
//
// Legend:
//
//   //          				-- comment
//   Name =      				-- non-terminal definition
//   'ident'     				-- token (terminal)
//   A B         				-- sequence
//   A | B       				-- alternation
//   A*          				-- zero or Psqlore repetition
//   (A (',' A)* ','?)	        -- repetition of node A separated by ',' and allowing a trailing comma
//   (A (',' A)*)	            -- repetition of node A separated by ',' without a trailing comma
//   A?          				-- zero or one repetition
//   (A)         				-- same as A
//   label:A     				-- suggested name for field of AST node

// NOTES
//
// - SyntaxNode, SyntaxToken and SyntaxElement will be stripped from the codegen
// - Bogus nodes are special nodes used to keep track of broken code; they are
//   not part of the grammar but they will appear inside the green tree
//


///////////////
// Bogus NODES
///////////////
// SyntaxElement is a generic data structure that is Psqleant to track nodes and tokens
// in cases where we care about both types
//
// As Bogus* node will need to yield both tokens and nodes without discrimination,
// and their children will need to yield nodes and tokens as well.
// For this reason, SyntaxElement = SyntaxElement
SyntaxElement = SyntaxElement

PsqlBogus = SyntaxElement*
PsqlBogusStatement = SyntaxElement*
PsqlBogusExpression = SyntaxElement*
PsqlBogusMember = SyntaxElement*
PsqlBogusBinding = SyntaxElement*
PsqlBogusAssignment = SyntaxElement*
PsqlBogusParameter = SyntaxElement*

///////////////
// Literals
///////////////
PsqlStringLiteralExpression = value: 'Psql_string_literal'
PsqlNumberLiteralExpression = value: 'Psql_number_literal'
PsqlBooleanLiteralExpression = value: ( 'true' | 'false' )
PsqlNullLiteralExpression = value: 'null'

PsqlName = value: 'ident'
PsqlStar = value: '*'

PsqlRoot = 
   stmt: PsqlStmtList
   eof: 'EOF'

PsqlStmtList = AnyPsqlStmt*

AnyPsqlStmt =
   PsqlSelectStmt
   | PsqlInsertStmt
   | PsqlDeleteStmt
   | PsqlUpdateStmt

///////////////
// Statements
///////////////

PsqlSelectStmt =
   select_clause: PsqlSelectClause
   from_clause: PsqlFromClause?
   where_clause: PsqlWhereClause?
   group_by_clause: PsqlGroupByClause?
   having_clause: PsqlHavingClause?
   order_by_clause: PsqlOrderByClause?
   limit_clause: PsqlLimitClause?
   offset_clause: PsqlOffsetClause?
   ';'?

PsqlSelectClause = 
   'select'
   list: PsqlSelectItemList

PsqlSelectItemList = (AnyPsqlSelectItem (',' AnyPsqlSelectItem)* ','?)

AnyPsqlSelectItem =
   PsqlStar
   | AnyPsqlExpression

PsqlFromClause =
   'from'
   clause: AnyPsqlFromExpression

AnyPsqlFromExpression =
   PsqlTableBinding
   | PsqlFunctionBinding
   | PsqlSubQuery

PsqlWhereClause =
   'where'
   condition: AnyPsqlExpression

PsqlGroupByClause = 
   'group_by' 
   items: PsqlGroupByItemList

PsqlGroupByItemList = (AnyPsqlExpression (',' AnyPsqlExpression)* ','?)

PsqlHavingClause =
   'having'
   condition: AnyPsqlExpression

PsqlLimitClause =
   'limit'
   limit_count: PsqlNumberLiteralExpression

PsqlOrderByClause =
   'order_by'
   items: PsqlOrderByExpressionList

PsqlOrderByExpressionList = (PsqlOrderByExpression (',' PsqlOrderByExpression)*)

PsqlOrderByExpression = 
   item: AnyPsqlExpression
   order: ('asc' | 'desc')?

PsqlOffsetClause =
   'offset'
   start: PsqlNumberLiteralExpression

PsqlInsertStmt =
   'insert'
   'into'
   table: PsqlTableBinding
   columns: PsqlInsertColumns?
   source: AnyPsqlInsertSource
   ';'?

PsqlInsertColumns = 
   '('
   items: PsqlInsertColumnList
   ')'

PsqlInsertColumnList = (PsqlName (',' PsqlName)*)

AnyPsqlInsertSource =
   PsqlInsertValues 
   | PsqlSelectStmt

PsqlInsertValues = 
   'values'
   '('
   items: PsqlExpressionList
   ')'

PsqlDeleteStmt = 
   'delete'
   'from'
   table: PsqlTableBinding
   using: PsqlDeleteUsingClause?
   where_clause: PsqlWhereClause?
   ';'?

PsqlDeleteUsingClause = 
   'using'
   AnyPsqlFromExpression

PsqlUpdateStmt = 
   'update'
   table: PsqlTableBinding
   set_clause: PsqlSetClause
   where_clause: PsqlWhereClause?
   ';'?

PsqlSetClause = 
   'set'
   items: PsqlSetItemList

PsqlSetItemList = (PsqlSetItem (',' PsqlSetItem)*)

PsqlSetItem = 
   column: PsqlName
   '='
   expr: AnyPsqlExpression

///////////////////////
// Parts of expressions
///////////////////////

PsqlTableColReference =
   table: PsqlTableName
   '.'
   name: PsqlName
   alias: PsqlAlias?

PsqlColReference =
   name: PsqlName
   alias: PsqlAlias?

PsqlSubQuery =
   '('
   PsqlSelectStmt
   ')'
   alias: PsqlAlias

PsqlAlias = 
   'as'?
   value: PsqlName

PsqlDataBaseName =
   name: PsqlName
   '.'

PsqlShemaName =
   base: PsqlDataBaseName?
   name: PsqlName
   '.'

PsqlTableName =
   schema: PsqlShemaName?
   name: PsqlName

PsqlTableBinding = 
   table: PsqlTableName
   alias: PsqlAlias?

PsqlFunctionBinding =
   schema: PsqlShemaName?
   name: PsqlName
   '('
   arguments: PsqlExpressionList
   ')'
   alias: PsqlAlias?

PsqlExpressionList = (AnyPsqlExpression (',' AnyPsqlExpression)* )

AnyPsqlExpression =
   PsqlName
   | PsqlTableColReference
   | PsqlColReference
   | PsqlSubQuery
   | PsqlBinaryExpression
   | PsqlLogicalExpression
   | PsqlParenthesizedExpression

PsqlBinaryExpression =
   left: AnyPsqlExpression
   operator_token: (
   '<' | '>' | '<=' | '>=' | '=' | '!=' | '<>'
   | '+' | '-' | '*' | '/' | '%' | '~'  | '!~'
   | '&' | '|' | '^' | '>>' | '<<' | '~*' | '!~*'
   )
   right: AnyPsqlExpression

PsqlLogicalExpression =
	left: AnyPsqlExpression
	operator_token: ('and' | 'or')
	right: AnyPsqlExpression

PsqlParenthesizedExpression =
	'(' expression: AnyPsqlExpression ')'

